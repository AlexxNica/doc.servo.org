initSidebarItems({"constant":[["AFFECTED_BY_CHILD_INDEX","Whether this element has matched any rule whose matching is determined by its position in the tree (i.e., first-child, nth-child, etc.)."],["AFFECTED_BY_EMPTY","Whether this element matches the :empty pseudo class."],["AFFECTED_BY_ID_SELECTOR","Whether this element is affected by an ID selector."],["AFFECTED_BY_NON_COMMON_STYLE_AFFECTING_ATTRIBUTE_SELECTOR","Whether this element is affected by a non-common style-affecting attribute."],["AFFECTED_BY_PRESENTATIONAL_HINTS","Whether this element is affected by presentational hints. This is computed externally (that is, in Servo)."],["AFFECTED_BY_PSEUDO_ELEMENTS","Whether this element has pseudo-element styles. Computed externally."],["AFFECTED_BY_SIBLINGS","Whether this element has matched any rule that is determined by a sibling (when using the `+` or `~` combinators)."],["AFFECTED_BY_STATE","Whether this flag is affected by any state (i.e., non tree-structural pseudo-class)."],["AFFECTED_BY_STYLE_ATTRIBUTE","Whether this element has a style attribute. Computed externally."],["HAS_EDGE_CHILD_SELECTOR","When a child is added or removed from this element, the first and last children must be restyled, because they may match :first-child, :last-child, or :only-child."],["HAS_EMPTY_SELECTOR","The element has an empty selector, so when a child is appended we might need to restyle the parent completely."],["HAS_SLOW_SELECTOR","When a child is added or removed from this element, all the children must be restyled, because they may match :nth-last-child, :last-of-type, :nth-last-of-type, or :only-of-type."],["HAS_SLOW_SELECTOR_LATER_SIBLINGS","When a child is added or removed from this element, any later children must be restyled, because they may match :nth-child, :first-of-type, or :nth-of-type."]],"enum":[["MatchingReason","The reason why we're doing selector matching."],["SelectorMatchingResult","A result of selector matching, includes 3 failure types,"]],"fn":[["can_fast_reject","Quickly figures out whether or not the complex selector is worth doing more work on. If the simple selectors don't match, or there's a child selector that does not appear in the bloom parent bloom filter, we can exit early."],["matches",""],["matches_complex_selector","Determines whether the given element matches the given complex selector."],["matches_complex_selector_internal",""],["matches_first_child",""],["matches_generic_nth_child",""],["matches_last_child",""],["matches_simple_selector","Determines whether the given element matches the given single selector."]],"static":[["RECOMMENDED_SELECTOR_BLOOM_FILTER_SIZE",""]],"struct":[["ElementFlags","Set of flags that are set on the parent depending on whether a child could potentially match a selector."],["StyleRelations","Set of flags that determine the different kind of elements affected by the selector matching process."]]});